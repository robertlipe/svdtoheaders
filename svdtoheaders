#!/usr/bin/env python3

import argparse
import os.path
import xmltodict

from pprint import pprint

def read_svd(svdfile):
  try:
    fp = open(svdfile)
    xml = fp.read()

    doc = xmltodict.parse(xml)
    return doc
  except IOError:
    print(f'Unable to open svd file "{svdfile}" for reading.')
    exit(1)

def humanBytes(bytes):
 if (bytes >= 1024**2):
   return str((int(bytes / 1024**2 ))) + "mB"
 if (bytes >= 1024):
    return str((int(bytes / 1024))) + "kB"
 return ("1kB")

# Gross. Remove internal whitespace from XML.
def cleanse(string):
  return " ".join(string.split())

# Example from old:
#define STM32_USART1_BASE    0x40011000     /* 0x40011000-0x400113ff: USART1 */

def peripherals(doc):
  """
  Returns a list of peripherals extracted from the JSON file.

    Returns:
        A list of peripheral dictionaries containing the following keys:
        - 'name': the name of the peripheral
        - 'baseAddress': the base address of the peripheral
        - 'description': a description of the peripheral (if available)
        - 'addressBlock': a dictionary containing the following keys (if available):
        - 'offset': the offset of the peripheral within the address space
        - 'size': the size of the address block allocated to the peripheral
  """
  defines = []
  base_addresses = {}
  sizes = {}
  for p in doc['device']['peripherals']['peripheral']:
    name = p['name']
    base_address = int(p['baseAddress'], 0)

    address_block = p.get('addressBlock', {})
    size = int(address_block.get('size', "0"), 0)
    #end_address = base_address

    if '@derivedFrom' in p:
      derived_from = p['@derivedFrom']
      size = sizes[derived_from] # BASE was already printed. derive size.

    end_address = base_address + size - 1

    base_addresses[name] = base_address
    sizes[name] = size

    symname = f"{prefix}{name.upper()}_BASE"
    define = f"#define {symname:<20} {hex(base_address)}"

    lname = cleanse(p.get('description', name))

    cmt = f" /* {base_address:#x}-{end_address:#x}: {humanBytes(size)} {lname} */"

    defines.append(define + cmt)


  defines.sort()
  #defines.sort(key=lambda x: x[0])
  return defines


def registers(doc):
  rv = []
  pperiphs = {}
  pdefines = {}
  # The heirarchy in the SVD is DEVICE->Peripherals->Registers->Fields
  peripherals = doc['device'].get('peripherals', {}).get('peripheral', [])
  for peripheral in peripherals:
    registers = peripheral.get('registers', {}).get('register', [])
    baseAddress = int(peripheral['baseAddress'], 0)
    # rv.{append(baseAddress)
    if isinstance(registers, dict):
      registers = [registers]
    p_name = cleanse(peripheral['name'])
    # You could be clever and dynamically size this. This isn't a bad default.
    column = 33
    if registers:
        p_name = cleanse(peripheral['name'])
        p_descr = cleanse(peripheral['description'])
        rv.append(f'\n/* {p_name} - {p_descr} */')

        reg_base = f"{prefix}{p_name}_BASE"
        rv.append(f'#define {reg_base:<{column}} 0x{baseAddress:x}')
        pdefines[reg_base] = hex(baseAddress)

        for register in registers:
          r_name = register['name']
          r_descr = cleanse(register.get('description', 'N/A'))
          r_base = int(register['addressOffset'], 0)
          regname = f"{prefix}{p_name}_{r_name}"
          offsetname = f"{regname}_OFFSET"

          rv.append(f'#define {offsetname:<{column}} 0x{r_base:04x}')
          pdefines[offsetname] = r_base
          rv.append(f'#define {regname:<{column}} ({reg_base} + {offsetname})')
          pdefines[regname] = offsetname

          fields = register.get('fields', {}).get('field', [])
          if isinstance(fields, dict):
            fields = [fields]
          if fields:
            for field in fields:
              f_name = field.get('name')
              f_descr = cleanse(field.get('description', 'N/A'))
              if 'bitOffset' in field and 'bitWidth' in field:
                bit_offset = int(field.get('bitOffset', 0))
                bit_width = int(field.get('bitWidth', 1))
                mask = (1 << bit_width) - 1

                b_name = prefix +  p_name + '_' + r_name + '_' + f_name
                rv.append(f'#define {b_name:<{column}} ({bit_width} << {bit_offset:>2})'
                          + f' /* {1<<bit_offset:02x}: {f_descr} */')
                pdefines[b_name] = None

                if(bit_width > 1):
                  maskname = b_name + "_MASK"
                  rv.append(f'#define {maskname:<{column + 5}} (0x{mask:02x})')
                  pdefines[maskname] = None
          pperiphs[p_name] = pdefines
        pdefines = {}
    else:
        d_name = peripheral['@derivedFrom']
        rv.append(f'\n/* No registers defined for peripheral {p_name}. Using those of {d_name}. */')
        registers = peripheral.get('registers', {}).get('register', [])
        reg_base = f"{prefix}{p_name}_BASE"
        rv.append(f'#define {reg_base:<{column}} 0x{baseAddress:x}')

        # Iterate over the original peripheral's defines and substitute the names and base address
        for original_name, original_value in pperiphs[d_name].items():
          # Skip the original base address; it was emitted long ago.
          if original_name == f"{prefix}{d_name}_BASE":
            continue

          # Replace the original peripheral's name with the current peripheral's name
          # So, for CH32V_SPI2_CTLR1_OFFSET  replace SPI2 with SPI1
          replaced_name = original_name.replace(d_name, p_name)
          replaced_value = original_name
          rv.append(f"#define {replaced_name:<{column}} {replaced_value}")

  return rv

# Command line args
mapfile = None
regfile = None
overwrite = None
svdfile = "ch32v30x.svd"
prefix = "CH32V_"
verbose = None

def clobberOk(file):
  if overwrite or not(os.path.isfile(file)):
    return True
  print (f'Unable to overwrite existing file "{file}".')
  exit(1)

def doParseArgs():
  global overwrite
  global regfile
  global mapfile
  global svdfile
  global prefix
  global verbose
  parser = argparse.ArgumentParser(description='Converts CMSSIS SVD to C headers.')
  parser.add_argument('-m', '--memorymap', action='store',
    help='Create file "memorymap" with mempory map of device.')
  parser.add_argument('-r', '--registers', action='store',
    help='Create file "registers" with registerss of device.')
  parser.add_argument('-p', '--prefix', action='store', default='CH32V_',
    help='Prefix C symbols with "prefix".')
  parser.add_argument('-s', '--svdfile', action='store' ,default='ch32v30x.svd',
    help='Read SVD source "file".')
  parser.add_argument('-v', '--verbose', action='store_true',
    help="Be vefbose about actions taken.")
  parser.add_argument('-o', '--overwrite', action='store_true',
    help="Allow overwrite")
  args = parser.parse_args()
  overwrite = args.overwrite
  regfile = args.registers
  mapfile = args.memorymap
  svdfile = args.svdfile
  prefix = args.prefix
  verbose = args.verbose

  if verbose:
    print(f"register file: {regfile}")
    print(f"memory map file: {mapfile}")
    print(f"svd file:  {svdfile}")
    print(f"prefix: {prefix}")
    print(f"Overwrite output files? {overwrite}")

def main():
  doParseArgs()
  if verbose:
    print(f"Reading {svdfile}")

  doc = read_svd(svdfile)

  if not mapfile and not regfile:
    print("Nothing to do You should probably specify either -p or -r.")
    exit(1)

  if mapfile and clobberOk(mapfile):
    if verbose:
      print(f"Writing memory map file {mapfile}")
    with open(mapfile, "w") as f:
      for p in (peripherals(doc)):
        print(p, file=f)
    f.close()

  if regfile and clobberOk(regfile):
    if verbose:
      print(f"Writing register file {regfile}")
    with open(regfile, "w") as f:
      for r in (registers(doc)):
        print(r, file=f)
    f.close()

main()
exit(0)
